<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Crash - Continuous Graph with Cashout Marker</title>
    
    
    <style>
       
  </style>
</head>
<body>

  <div class="crash-container">
      <!-- Game Title -->
      <h2>🚀 Neon Crash 🚀</h2>

      <!-- Current Multiplier Display -->
      <div id="multiplierDisplay">X 0.00</div>

      <!-- Canvas for the graph -->
      <canvas id="crashCanvas" width="300" height="200"></canvas>

      <div class="controls">
          <!-- Start Button (Ad/Real Game) -->
          <button class="action-button breathing-neon" id="betButton">Start Game (Ad)</button> 
          <!-- Demo Mode Button -->
          <button class="action-button" id="demoButton">Demo Play (Free)</button>
          
          <!-- Final Claim/Start button shown in the second phase -->
          <button class="action-button" id="cashOutButton">Claim</button>
      </div>
      
      <!-- Game Status Message -->
      <p id="message">Waiting for the next round...</p>
  </div>


  


  <script>
      // --- Canvas and UI Setup ---
      const canvas = document.getElementById('crashCanvas');
      const ctx = canvas.getContext('2d');
      const multiplierDisplay = document.getElementById('multiplierDisplay');
      const betButton = document.getElementById('betButton');
      const demoButton = document.getElementById('demoButton'); 
      const cashOutButton = document.getElementById('cashOutButton');
      const messageDisplay = document.getElementById('message');
      const crashContainer = document.querySelector('.crash-container'); 

      const CANVAS_WIDTH = 300;
      const CANVAS_HEIGHT = 200;
      
      // Adjust canvas size for mobile responsiveness
      function resizeCanvas() {
          const containerWidth = crashContainer.clientWidth - 40; // Subtract padding
          canvas.width = containerWidth;
          canvas.height = containerWidth * (2/3); // Maintain 3:2 aspect ratio
          drawGraph(); 
      }
      window.addEventListener('resize', resizeCanvas);
      
      // --- Game Constants and Variables ---
      const START_COLOR = '#00ff80'; 
      const RISING_COLOR = '#00ffff'; 
      const CRASH_COLOR = '#ff004c'; 
      const WARNING_ORANGE = '#ff9900'; 
      const BG_GRID_COLOR = '#222'; 
      const NEON_BET_YELLOW = '#ffcc00'; 
      
      const WARNING_THRESHOLD = 0.35; 
      const FINAL_MAX_CRASH = 3.00;   
      
      const NEON_PULSE_COLORS = ['#e000ff', '#0099ff', RISING_COLOR, START_COLOR, NEON_BET_YELLOW]; 
      const DEFAULT_DISPLAY_COLOR = 'white'; 
      const DEFAULT_DISPLAY_SHADOW = '0 0 10px #00ff80'; 

      let gameState = 'waiting'; 
      let currentMultiplier = 0.00; 
      let crashPoint = 0; 
      let betPlaced = false; 
      let isDemoMode = false; 
      let cashedOut = false;
      let animationFrameId = null;
      let startTime = 0;
      
      let graphPoints = [];
      let scaleFactor = 1.0; 
        let isFlashing = false; 
        let breathingBlur = 10; 
        let cashOutPoint = null; 
        let pulsingIntervalId = null; 
        let colorCycleIntervalId = null; 
        let pulseColor = ''; 
        let colorIndex = 0; 
        let brightnessPhase = 0; 

        // --- Main Functions ---

        /**
         * New function: Transition to pending_start state after ad completion.
         * (Call this function in the successful ad completion callback from your Ad SDK)
         */
        function onAdCompleted() {
            // Hide initial buttons
            betButton.style.display = 'none';
            demoButton.style.display = 'none';
            
            // Show the Claim/CashOut button as the final START button
            cashOutButton.style.display = 'block';
            cashOutButton.textContent = 'START';
            cashOutButton.classList.remove('delay-disabled');
            cashOutButton.classList.remove('loading-ad'); // Remove loading state
            cashOutButton.disabled = false;
            
            messageDisplay.textContent = 'Ready for takeoff. Click START!';
            messageDisplay.style.color = NEON_BET_YELLOW;
            
            gameState = 'pending_start'; 
        }

        /**
         * Ad display simulation function (2 seconds).
         * In a real application, you would remove this and replace it with your Ad SDK logic.
         */
        function simulateAd() {
            messageDisplay.textContent = '...Loading and displaying Ad (Simulating 2 seconds)';
            messageDisplay.style.color = 'var(--ad-loading)';
            
            betButton.classList.add('loading-ad');
            betButton.textContent = 'Loading Ad...';
            betButton.disabled = true;
            demoButton.disabled = true;
            
            setTimeout(() => {
                betButton.classList.remove('loading-ad');
                // Call onAdCompleted after successful ad display
                onAdCompleted();
            }, 2000); 
        }

        function startRound() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            stopPulsingEffect(); 
            startPulsingEffect(null, 'waiting'); 
            
            // Determine random crash point
            const R = Math.max(0.001, Math.random()); 
            let rawCrash;
            if (R < 0.6) {
                rawCrash = 1.50 + Math.random() * 1.0; 
            } else {
                rawCrash = 2.50 + Math.random() * 1.5;
            }
            crashPoint = Math.min(rawCrash, FINAL_MAX_CRASH); 
            crashPoint = parseFloat(crashPoint.toFixed(2));


            currentMultiplier = 0.00; 
            betPlaced = false; 
            isDemoMode = false; 
            cashedOut = false;
            gameState = 'betting'; 
            startTime = 0;
            scaleFactor = 1.0; 
            isFlashing = false; 
            cashOutPoint = null; 
            graphPoints = [{x: 0, y: CANVAS_HEIGHT}]; 
            
            multiplierDisplay.textContent = 'X 0.00'; 
            multiplierDisplay.style.color = DEFAULT_DISPLAY_COLOR;
            multiplierDisplay.style.textShadow = DEFAULT_DISPLAY_SHADOW;
            multiplierDisplay.style.transform = 'translate(0, 0)'; 
            
            messageDisplay.textContent = 'Waiting for the next round...';

            // Set initial buttons for selection
            betButton.disabled = false;
            betButton.textContent = 'Start Game (Ad)'; // UPDATED TEXT HERE
            betButton.classList.remove('disabled-button', 'delay-disabled', 'loading-ad');
            betButton.style.display = 'block'; 
            betButton.classList.add('breathing-neon'); 
            
            demoButton.disabled = false;
            demoButton.textContent = 'Demo Play (Free)';
            demoButton.classList.remove('disabled-button');
            demoButton.style.display = 'block'; 
            
            cashOutButton.style.display = 'none';
            cashOutButton.textContent = 'Claim'; 
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGraph(); 
        }

        function handleBetStart(isDemo = false) {
            
            // If the button is a restart button, restart the round
            if (betButton.textContent === 'Restart Round' && !isDemo) {
                if (!betButton.disabled) {
                    startRound();
                }
                return;
            }
            
            // Initial selection logic
            if (gameState === 'betting' || gameState === 'waiting') {
                
                betPlaced = !isDemo; 
                isDemoMode = isDemo; 
                
                betButton.classList.remove('breathing-neon'); 
                
                if (isDemo) {
                    // Demo Mode: Immediate start
                    demoButton.textContent = `Round in progress...`;
                    betButton.style.display = 'none'; 
                    beginRising(); 
                    
                } else {
                    // Ad/Real Mode: Start ad process
                    simulateAd();
                }
            } else if (gameState === 'crashed' || gameState === 'cashedOut') {
                startRound();
            }
        }

        // Handle Claim/START button click
        function handleClaimClick() {
            if (gameState === 'pending_start' && cashOutButton.textContent.toUpperCase() === 'START') {
                beginRising(); 
                return;
            }
            
            // Normal Cash Out logic
            cashOut();
        }

        function beginRising() {
            if (gameState !== 'betting' && gameState !== 'pending_start') return; 
            
            gameState = 'rising';
            startTime = Date.now();
            messageDisplay.textContent = 'Flight started! Claim at any multiplier!';
            messageDisplay.style.color = START_COLOR;
            
            // Set up Claim button
            cashOutButton.style.backgroundColor = 'var(--neon-start)';
            cashOutButton.style.boxShadow = '0 0 15px var(--neon-start)';
            cashOutButton.textContent = 'Claim'; 
            cashOutButton.disabled = false;
            
            // Disable initial buttons
            betButton.classList.add('disabled-button');
            betButton.disabled = true; 
            demoButton.classList.add('disabled-button');
            demoButton.disabled = true;
            
            cashOutButton.style.display = 'block';
            
            stopPulsingEffect(); 
            animate(); 
        }
        
        function activateResetButtonAfterDelay() {
            // Show the restart button
            betButton.style.display = 'block';
            betButton.textContent = 'Restart Round';
            
            // Apply disabled/gray state for one second
            betButton.classList.add('delay-disabled');
            betButton.classList.remove('disabled-button'); 
            betButton.disabled = true; 

            setTimeout(() => {
                // Re-enable the button
                betButton.classList.remove('delay-disabled');
                betButton.disabled = false;
                betButton.classList.add('breathing-neon'); 
            }, 1000); 
        }


        function cashOut() {
            if (gameState !== 'rising' || cashedOut) return;

            if (currentMultiplier <= 0.00) {
                messageDisplay.textContent = '⚠️ Wait! Multiplier must be above 0.00.';
                messageDisplay.style.color = CRASH_COLOR;
                return;
            }
            cashedOut = true;
            
            // Record the exact Cash Out point on the graph
            cashOutPoint = graphPoints[graphPoints.length - 1]; 

            const cashOutMultiplier = currentMultiplier.toFixed(2);
            
            if (isDemoMode) {
                 messageDisplay.textContent =` 🎉 DEMO CLAIMED at X${cashOutMultiplier}. No coins won.`;
            } else {
                const winnings = currentMultiplier; 
                messageDisplay.textContent =` ✅ CASHED OUT at X${cashOutMultiplier}. Your winnings: ${winnings.toFixed(2)} coins.`;
            }

            messageDisplay.style.color = START_COLOR;
            
            // Visually disable the Claim button
            cashOutButton.disabled = true;
            cashOutButton.style.backgroundColor = '#222';
            cashOutButton.style.boxShadow = 'none';
            cashOutButton.textContent = `PAID X${cashOutMultiplier}`;
        }

        function endRound(isManualCashOut) {
            cancelAnimationFrame(animationFrameId);
            gameState = 'crashed'; 
            isFlashing = false; 
            
            multiplierDisplay.style.transform = 'translate(0, 0)'; 
            
            if (!cashedOut) {
                multiplierDisplay.textContent = `X ${crashPoint.toFixed(2)}`;
                multiplierDisplay.style.color = CRASH_COLOR;
                
                if (isDemoMode) {
                     messageDisplay.textContent =` 💥 Demo CRASHED at X${crashPoint.toFixed(2)}. Start a new round!`;
                     messageDisplay.style.color = WARNING_ORANGE;
                } else {
                    messageDisplay.textContent =` 💥 CRASHED at X${crashPoint.toFixed(2)}. No coins won.`;
                    messageDisplay.style.color = CRASH_COLOR;
                }
                
                // Crash explosion effect
                if (graphPoints.length > 0) {
                    const finalPoint = graphPoints[graphPoints.length - 1];
                    ctx.fillStyle = CRASH_COLOR;
                    
                    for (let r = 0; r < 50; r += 10) {
                        ctx.globalAlpha = 1 - (r / 50); 
                        ctx.beginPath();
                        const explosionX = finalPoint.x / scaleFactor;
                        const explosionY = finalPoint.y / scaleFactor;
                        ctx.arc(explosionX, explosionY, r / scaleFactor, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1.0; 
                }
            }

            cashOutButton.style.display = 'none';
            demoButton.style.display = 'none'; 
            
            const pulseColor = (cashedOut) ? START_COLOR : CRASH_COLOR;
            startPulsingEffect(pulseColor, 'result'); 
            
            activateResetButtonAfterDelay();
        }

        // --- Core Animation Function ---
        function animate() {
            if (gameState !== 'rising') return;

            const now = Date.now();
            const elapsedTime = (now - startTime) / 1000;
            
            // Multiplier calculation logic (based on elapsed time)
            breathingBlur = 10 + Math.sin(now / 200) * 3; 
            const C = 0.05; 
            const T_POWER = 1.2; 
            const effectiveTime = Math.pow(elapsedTime, T_POWER);
            let baseMultiplier = (Math.expm1(effectiveTime * C) * 3); 
            
            const DIP_AMPLITUDE = 0.10; 
            const sinePhase = (baseMultiplier / 0.5) * Math.PI;
            const sineWave = Math.sin(sinePhase);
            let dipValue = (baseMultiplier > 0.10) ? (sineWave * DIP_AMPLITUDE * Math.min(1.0, baseMultiplier / 2.0)) : 0;
            
            currentMultiplier = Math.floor((baseMultiplier + dipValue) * 100) / 100;
            currentMultiplier = Math.max(0.00, currentMultiplier);
            
            const distanceToCrash = crashPoint - currentMultiplier;
            
            // --- Crash Warning Section ---
            // If the multiplier is within 0.35 of the crash point, start flashing
            if (distanceToCrash <= WARNING_THRESHOLD && distanceToCrash > 0.01 && !cashedOut) {
                isFlashing = true;
                if (Math.floor(now / 150) % 2 === 0) {
                    cashOutButton.style.backgroundColor = CRASH_COLOR;
                    cashOutButton.style.boxShadow =` 0 0 15px ${CRASH_COLOR}`;
                } else {
                    cashOutButton.style.backgroundColor = WARNING_ORANGE;
                    cashOutButton.style.boxShadow =` 0 0 15px ${WARNING_ORANGE}`;
                }
                messageDisplay.textContent = '🚨 CRASH Danger! Claim quickly! 🚨';
                messageDisplay.style.color = WARNING_ORANGE;
                messageDisplay.textShadow =` 0 0 5px ${CRASH_COLOR}`;
            } else if (!cashedOut) {
                isFlashing = false;
                cashOutButton.style.backgroundColor = 'var(--neon-start)';
                cashOutButton.style.boxShadow = '0 0 15px var(--neon-start)';
                messageDisplay.textContent = 'Flight started! Claim at any multiplier!';
                messageDisplay.style.color = 'var(--neon-start)';
                messageDisplay.textShadow = '0 0 5px var(--neon-start)';
            }
            
            // --- Multiplier Jitter and Color ---
            if (currentMultiplier > 1.5) {
                const jitter = Math.min(5, (currentMultiplier - 1.0) * 0.5); 
                const randomX = (Math.random() - 0.5) * jitter;
                const randomY = (Math.random() - 0.5) * jitter;
                multiplierDisplay.style.transform =` translate(${randomX}px, ${randomY}px)`;
                
                const hue = 120 - Math.min(120, currentMultiplier * 10); 
                multiplierDisplay.style.color =` hsl(${hue}, 100%, 70%)`;
                multiplierDisplay.style.textShadow =` 0 0 ${Math.min(20, currentMultiplier * 3)}px hsl(${hue}, 100%, 50%)`;
            } else {
                multiplierDisplay.style.transform = `translate(0, 0)`;
                multiplierDisplay.style.color = DEFAULT_DISPLAY_COLOR;
                multiplierDisplay.style.textShadow = DEFAULT_DISPLAY_SHADOW;
            }

            // Scaling logic and record new point
            const X_PACE = canvas.width / 10;
            const X_LIMIT_PERCENTAGE = 0.85; 

            const totalX = elapsedTime * X_PACE * 1.5; 
            const newY = getGraphY(currentMultiplier);
            
            const maxX = totalX; 
            const maxY = canvas.height - newY; 
            
            const MAX_ALLOWED_X = canvas.width * X_LIMIT_PERCENTAGE; 
            
            let requiredScaleX = MAX_ALLOWED_X / maxX;
            let requiredScaleY = canvas.height / maxY;
            
            scaleFactor = Math.min(1.0, requiredScaleX, requiredScaleY);
            if (scaleFactor < 0.01) scaleFactor = 0.01; 

            graphPoints.push({x: totalX, y: newY}); 
            
            drawGraph();

            multiplierDisplay.textContent = `X ${currentMultiplier.toFixed(2)}`;
            
            // Update Claim button text
            if (!cashedOut && cashOutButton.textContent.toUpperCase() !== 'START') {
                 cashOutButton.textContent = isDemoMode ? `Claim (Demo - X${currentMultiplier.toFixed(2)})` : `Claim (X${currentMultiplier.toFixed(2)})`;
            }

            if (currentMultiplier >= crashPoint) {
                endRound(false); 
                return;
            }

            animationFrameId = requestAnimationFrame(animate);
          }
        
          // --- Canvas Helper Functions ---
          
          const getGraphY = (multiplier) => {
              const adjustedMultiplier = Math.max(1.01, multiplier + 1.0); 
              const yOffset = (Math.log10(adjustedMultiplier) * 60); 
              return canvas.height - Math.min(yOffset * 2.5, canvas.height); 
          };
  
          function drawGraph() {
              ctx.fillStyle = 'rgba(17, 17, 17, 0.2)'; 
              ctx.fillRect(0, 0, canvas.width, canvas.height);
  
              ctx.save();
              ctx.translate(0, canvas.height); 
              ctx.scale(scaleFactor, scaleFactor); 
              ctx.translate(0, -canvas.height); 
  
              ctx.strokeStyle = BG_GRID_COLOR; 
              ctx.lineWidth = 1 / scaleFactor;
              
              const horizontalStep = 40; 
              const verticalStep = 30;
              
              const maxGridX = canvas.width / scaleFactor;
              const maxGridY = canvas.height / scaleFactor;
  
              // Draw grid lines
              for (let y = -horizontalStep * 2; y <= maxGridY + horizontalStep * 2; y += horizontalStep) { 
                  ctx.beginPath();
                  ctx.moveTo(-verticalStep * 2, y); 
                  ctx.lineTo(maxGridX + verticalStep * 2, y); 
                  ctx.stroke();
              }
              for (let x = -verticalStep * 2; x <= maxGridX + verticalStep * 2; x += verticalStep) { 
                  ctx.beginPath();
                  ctx.moveTo(x, -horizontalStep * 2); 
                  ctx.lineTo(x, maxGridY + horizontalStep * 2); 
                  ctx.stroke();
              }
  
              if (graphPoints.length < 2) {
                  ctx.fillStyle = START_COLOR;
                  ctx.beginPath();
                  ctx.arc(0, canvas.height, 4 / scaleFactor, 0, Math.PI * 2); 
                  ctx.fill();
                  ctx.restore(); 
                  return; 
              }
  
              // Draw graph line
              let lineColor = RISING_COLOR; 
              let shadowBlur = breathingBlur; 
              
              if (isFlashing) {
                  lineColor = (Math.floor(Date.now() / 100) % 2 === 0) ? CRASH_COLOR : WARNING_ORANGE;
                  shadowBlur = 15; 
              }
              
              ctx.strokeStyle = lineColor;
              ctx.shadowColor = lineColor;
              ctx.shadowBlur = shadowBlur / scaleFactor; 
              ctx.lineWidth = 3 / scaleFactor; 
  
              ctx.beginPath();
              ctx.moveTo(graphPoints[0].x, graphPoints[0].y); 
  
              for (let i = 1; i < graphPoints.length; i++) {
                  ctx.lineTo(graphPoints[i].x, graphPoints[i].y);
              }
              
              ctx.stroke();
  
              // Draw current point (tip of the graph)
              const lastPoint = graphPoints[graphPoints.length - 1];
              ctx.fillStyle = lineColor;
              ctx.beginPath();
              ctx.arc(lastPoint.x, lastPoint.y, 4 / scaleFactor, 0, Math.PI * 2); 
              ctx.fill();
              
              // Draw Cashout Point marker
              if (cashOutPoint) {
                  ctx.shadowBlur = 10 / scaleFactor; 
                  ctx.shadowColor = START_COLOR; 
                  ctx.fillStyle = START_COLOR;
                  
                  ctx.beginPath();
                  const cashoutX = cashOutPoint.x;
                  const cashoutY = cashOutPoint.y;
                  ctx.arc(cashoutX, cashoutY, 6 / scaleFactor, 0, Math.PI * 2); 
                  ctx.fill();
                  
                  ctx.shadowBlur = 0; 
                  ctx.fillStyle = 'white';
                  ctx.beginPath();
                  ctx.arc(cashoutX, cashoutY, 2 / scaleFactor, 0, Math.PI * 2); 
                  ctx.fill();
              }
  
              ctx.shadowBlur = 0;
              ctx.restore(); 
          }
  
          // --- Pulse Effect Functions ---
          function startPulsingEffect(color, mode = 'result') {
              stopPulsingEffect();
              pulseColor = color; 
            brightnessPhase = 0;
            
            if (mode === 'waiting') {
                colorIndex = 0;
                colorCycleIntervalId = setInterval(() => {
                    colorIndex = (colorIndex + 1) % NEON_PULSE_COLORS.length;
                    crashContainer.style.borderColor = NEON_PULSE_COLORS[colorIndex]; 
                }, 500); 
            }

            pulsingIntervalId = setInterval(() => {
                
                brightnessPhase += 0.1; 
                const shadowStrength = 10 + Math.sin(brightnessPhase) * 5; 
                
                let currentEffectColor = pulseColor;

                if (mode === 'waiting') {
                    currentEffectColor = NEON_PULSE_COLORS[colorIndex];
                    
                    multiplierDisplay.style.color = DEFAULT_DISPLAY_COLOR;
                    multiplierDisplay.style.textShadow = DEFAULT_DISPLAY_SHADOW;
                } else {
                    multiplierDisplay.style.color = currentEffectColor;
                    multiplierDisplay.style.textShadow =` 0 0 ${10 + Math.sin(brightnessPhase) * 3}px ${currentEffectColor}`; 
                }
                
                crashContainer.style.boxShadow = `0 0 ${25 + shadowStrength}px ${currentEffectColor}`;

            }, 100); 
        }

        function stopPulsingEffect() {
            if (pulsingIntervalId) {
                clearInterval(pulsingIntervalId);
                pulsingIntervalId = null;
            }
            if (colorCycleIntervalId) {
                 clearInterval(colorCycleIntervalId);
                colorCycleIntervalId = null;
            }
            crashContainer.style.boxShadow = '0 0 25px var(--neon-bet)'; 
            crashContainer.style.borderColor = 'var(--neon-bet)'; 
        }

        // --- Event Listeners ---
        function setupEventListeners() {
            betButton.addEventListener('click', () => handleBetStart(false)); 
            demoButton.addEventListener('click', () => handleBetStart(true));  
            
            cashOutButton.addEventListener('click', handleClaimClick);
        }


        // --- Initial Start ---
        window.onload = function() {
            resizeCanvas(); // Initial canvas size setup
            startRound();
            setupEventListeners(); 
        };

    </script>
</body>
</html>